

# OpenCV

## 一、图像基本操作

​	图像由**像素点**构成【0~255---表示亮度】

​	像素点是由矩阵构成的，矩阵表示图像的大小。（e-g：彩色500*500的图像，对应的矩阵大小为 [ 500,500,3 ] ）

### 1.1 图像读取

```python
import cv2 #默认读取格式是BGR，和matplotlib有冲突

"""
H = 有多少行这样的像素行

W = 每一行里有多少个 [B G R]

C = 每个像素有多少个颜色通道（B、G、R 三个数）
"""

#e-g1：../photos/img1.jpg
img = cv2.imread('../photos/img1.jpg')
print(img)

[[[ 79  47  28]
  [ 79  47  28]
  [ 79  46  27]
  ...
  [128  49  38]
  [128  49  38]
  [128  49  38]]

 [[ 79  47  28]
  [ 79  47  28]
  [ 78  46  27]
  ...
  [128  49  38]
  [128  49  38]
  [128  49  38]]

 [[ 79  47  28]
  [ 79  47  28]
  [ 78  46  27]
  ...
  [128  49  38]
  [128  49  38]
  [128  49  38]]

 ...

 [[108  39  72]
  [110  40  76]
  [112  42  79]
  ...
  [254 235 178]
  [254 236 175]
  [254 237 174]]

 [[108  39  72]
  [110  40  76]
  [112  42  79]
  ...
  [243 214 187]
  [243 215 185]
  [243 215 184]]

 [[108  39  72]
  [110  40  76]
  [112  42  79]
  ...
  [233 197 189]
  [232 197 187]
  [232 198 185]]]

#e-g2: ../photos/img1.jpg 灰度图展示
img = cv2.imread('../photos/img1.jpg' , cv2.IMREAD_GRAYSCALE)
print(img)
[[ 45  45  44 ...  55  55  55]
 [ 45  45  44 ...  55  55  55]
 [ 45  45  44 ...  55  55  55]
 ...
 [ 57  59  61 ... 220 220 220]
 [ 57  59  61 ... 209 209 209]
 [ 57  59  61 ... 199 198 198]]
```

### 1.2 图像显示

```python
#<===显示图像===>
cv2.imshow('img1', img)

#参数t = 0 :按任意键退出
#参数t > 0 :显示t毫秒自动退出
cv2.waitKey(0) 
cv2.destroyAllWindows()


#<===指定显示图像类型===>
#1. 读取灰度图
img = cv2.imread('../photos/img1.jpg' , cv2.IMREAD_GRAYSCALE)

#2. 读取RGB图
img = cv2.cvtColor('../photos/img1.jpg', cv2.COLOR_BGR2RGB)
```

### 1.3 图像属性

```python
#shape属性【分别是 H高度 ， W宽度 ， C通道数】【返回的是 BGR 格式】

#e-g：../photos/img1.jpg
print(img.shape)
(2160, 3840, 3)

#e-g2: ../photos/img1.jpg 灰度图展示
print(img.shape)
(2160, 3840) #只有H,W两个通道

#type() 显示图像类型
print(type(img)) 
<class 'numpy.ndarray'>

#.size 显示图片尺寸
#e-g：../photos/img1.jpg
print(img.size)
24883200

#e-g2: ../photos/img1.jpg 灰度图展示
print(img.size)
8294400 #8294400 * 3 = 24883200

#.dtype 显示数据类型
print(img.dtype)
uint8
```

### 1.4 图像保存

```python
cv2.imwrite('路径' , 保存名)
```



## 二、视频基本操作

### 2.1 视频读取

```python
#<===视频读取===>
vc = cv2.VideoCapture('../videos/vc1.mp4')

#检查是否打开正确
if vc.isOpened():
    #open: bool类型值，表示该帧是否能读出来
    #frame: 表示当前这一帧的图像
    open , frame = vc.read()
else:
    open = False
```

### 2.2 视频显示

```python
def play(open):
    while open:
        ret , frame = vc.read()
        if frame is None: #视频读取完，直接跳出
            break
        if ret == True: #如果当前成功读取到帧
            # gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) #存储灰度图
            # cv2.imshow('frame', gray) #展示灰度图

            cv2.imshow('frame', frame)

            #每隔 10ms 检查一次键盘，如果按下 Esc 键（ASCII=27），就退出循环。
            #每帧显示后等待 10ms → 约等于 1000/10 = 100 FPS 的刷新速度
            #参数 x 越小，视频播放速度越快
            if cv2.waitKey(10) & 0xFF == 27:
                #cv2.waitKey(10)等待键盘输入，参数 10 表示等待 10 毫秒
                #& 0xFF作用是取 cv2.waitKey() 返回值的低 8 位,保证跨平台时只保留有效的 ASCII 值
                #27 对应 Esc 键
                break
    vc.release() #释放视频流/摄像头资源
    cv2.destroyAllWindows() #关闭所有 OpenCV 创建的窗口
```

### 2.3 视频操作

```python
#<===截取部分图像数据===>
def cv_show(name , img):
    cv2.imshow(name, img)
    cv2.waitKey(0)
    cv2.destroyAllWindows()

img = cv2.imread('../photos/img1.jpg')
Ic = img[0:200 , 0:200] #设置切片
cv_show('silver wolf' , Ic)


#<===通道提取===>
img = cv2.imread('../photos/img1.jpg')
b,g,r = cv2.split(img)
print(r)

#<===通道形状===>
img = cv2.imread('../photos/img1.jpg')
b,g,r = cv2.split(img)
print(b.shape)
print(g.shape)
print(r.shape)
	#像素值可能不一样，但形状一定是一样的
    #split 时，实际上是把 (H, W, 3) 划分为 3 个 (H, W) 的二维矩阵，形状一定一样。
    
#<===通道整合===>
img = cv2.imread('../photos/img1.jpg')
b,g,r = cv2.split(img)

img_new = cv2.merge((b,g,r))
print(img_new.shape)
cv_show('img_new', img_new)

#<===通道限制===>
#1. 只保留R
img = cv2.imread('../photos/img1.jpg')
cur_imgs = img.copy() #备份
cur_imgs[:,:,0] = 0 #B消除
cur_imgs[:,:,1] = 0 #G消除
cv_show('R', cur_imgs)
```

## 三、边界填充

```python
#<===边界填充===>
img = cv2.imread('../photos/img1.jpg')
img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB) #转成RGB
#规定上、下、左、右填充的大小
top_size , bottom_size , left_size , right_size = (50 , 50 , 50 , 50)
#此时四周补的像素个数是50

#BORDER_REPLICATE 复制法——复制最边缘像素
replicate = cv2.copyMakeBorder(img , top_size , bottom_size , left_size , right_size, cv2.BORDER_REPLICATE)
#BORDER_REFLECT 反射法——镜像反射填充(像一面镜子，把边界外第一个点当作“镜像起点” !!! 包含边界像素本身)—— eg: e d c b a | a b c d e | e d c b a
reflect = cv2.copyMakeBorder(img , top_size , bottom_size , left_size , right_size, cv2.BORDER_REFLECT)
#BORDER_REFLECT 反射法——镜像反射填充(像一面镜子，把边界外第一个点当作“镜像起点” !!! 不包含边界像素本身)—— eg: e d c b | a b c d e | d c b a
reflect101 = cv2.copyMakeBorder(img , top_size , bottom_size , left_size , right_size, cv2.BORDER_REFLECT_101)
#cv2.BORDER_WRAP 外包装法(复制) e-g: abcdefg | abcdefg | abcdefg
wrap = cv2.copyMakeBorder(img, top_size , bottom_size , left_size , right_size, cv2.BORDER_WRAP)
# cv2.BORDER_CONSTANT 常量法(用常数值填充)
constant = cv2.copyMakeBorder(img, top_size , bottom_size , left_size , right_size, cv2.BORDER_CONSTANT)

plt.subplot(231) , plt.imshow(img , 'grey') , plt.title('Original')
plt.subplot(232) , plt.imshow(replicate , 'grey') , plt.title('Replicate')
plt.subplot(233) , plt.imshow(reflect , 'grey') , plt.title('Reflect')
plt.subplot(234) , plt.imshow(reflect101 , 'grey') , plt.title('Reflect101')
plt.subplot(235) , plt.imshow(wrap , 'grey') , plt.title('Wrap')
plt.subplot(236) , plt.imshow(constant , 'grey') , plt.title('Constant')
plt.show()
```
